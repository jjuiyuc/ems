// Code generated by SQLBoiler 4.11.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package deremsmodels

import (
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// CCDataLog is an object representing the database table.
type CCDataLog struct {
	ID                                int64        `boil:"id" json:"id" toml:"id" yaml:"id"`
	GWUUID                            string       `boil:"gw_uuid" json:"gwUUID" toml:"gwUUID" yaml:"gwUUID"`
	LogDate                           time.Time    `boil:"log_date" json:"logDate" toml:"logDate" yaml:"logDate"`
	GWID                              null.Int64   `boil:"gw_id" json:"gwID,omitempty" toml:"gwID" yaml:"gwID,omitempty"`
	CustomerID                        null.Int64   `boil:"customer_id" json:"customerID,omitempty" toml:"customerID" yaml:"customerID,omitempty"`
	GridIsPeakShaving                 null.Int     `boil:"grid_is_peak_shaving" json:"gridIsPeakShaving,omitempty" toml:"gridIsPeakShaving" yaml:"gridIsPeakShaving,omitempty"`
	LoadGridAveragePowerAC            null.Float32 `boil:"load_grid_average_power_ac" json:"loadGridAveragePowerAc,omitempty" toml:"loadGridAveragePowerAc" yaml:"loadGridAveragePowerAc,omitempty"`
	BatteryGridAveragePowerAC         null.Float32 `boil:"battery_grid_average_power_ac" json:"batteryGridAveragePowerAc,omitempty" toml:"batteryGridAveragePowerAc" yaml:"batteryGridAveragePowerAc,omitempty"`
	GridContractPowerAC               null.Float32 `boil:"grid_contract_power_ac" json:"gridContractPowerAc,omitempty" toml:"gridContractPowerAc" yaml:"gridContractPowerAc,omitempty"`
	LoadPvAveragePowerAC              null.Float32 `boil:"load_pv_average_power_ac" json:"loadPVAveragePowerAc,omitempty" toml:"loadPVAveragePowerAc" yaml:"loadPVAveragePowerAc,omitempty"`
	LoadBatteryAveragePowerAC         null.Float32 `boil:"load_battery_average_power_ac" json:"loadBatteryAveragePowerAc,omitempty" toml:"loadBatteryAveragePowerAc" yaml:"loadBatteryAveragePowerAc,omitempty"`
	BatterySoC                        null.Float32 `boil:"battery_soc" json:"batterySoc,omitempty" toml:"batterySoc" yaml:"batterySoc,omitempty"`
	BatteryProducedAveragePowerAC     null.Float32 `boil:"battery_produced_average_power_ac" json:"batteryProducedAveragePowerAc,omitempty" toml:"batteryProducedAveragePowerAc" yaml:"batteryProducedAveragePowerAc,omitempty"`
	BatteryConsumedAveragePowerAC     null.Float32 `boil:"battery_consumed_average_power_ac" json:"batteryConsumedAveragePowerAc,omitempty" toml:"batteryConsumedAveragePowerAc" yaml:"batteryConsumedAveragePowerAc,omitempty"`
	BatteryChargingFrom               null.String  `boil:"battery_charging_from" json:"batteryChargingFrom,omitempty" toml:"batteryChargingFrom" yaml:"batteryChargingFrom,omitempty"`
	BatteryDischargingTo              null.String  `boil:"battery_discharging_to" json:"batteryDischargingTo,omitempty" toml:"batteryDischargingTo" yaml:"batteryDischargingTo,omitempty"`
	PvAveragePowerAC                  null.Float32 `boil:"pv_average_power_ac" json:"pvAveragePowerAc,omitempty" toml:"pvAveragePowerAc" yaml:"pvAveragePowerAc,omitempty"`
	LoadAveragePowerAC                null.Float32 `boil:"load_average_power_ac" json:"loadAveragePowerAc,omitempty" toml:"loadAveragePowerAc" yaml:"loadAveragePowerAc,omitempty"`
	LoadLinks                         null.JSON    `boil:"load_links" json:"loadLinks,omitempty" toml:"loadLinks" yaml:"loadLinks,omitempty"`
	GridLinks                         null.JSON    `boil:"grid_links" json:"gridLinks,omitempty" toml:"gridLinks" yaml:"gridLinks,omitempty"`
	PvLinks                           null.JSON    `boil:"pv_links" json:"pvLinks,omitempty" toml:"pvLinks" yaml:"pvLinks,omitempty"`
	BatteryLinks                      null.JSON    `boil:"battery_links" json:"batteryLinks,omitempty" toml:"batteryLinks" yaml:"batteryLinks,omitempty"`
	BatteryPvAveragePowerAC           null.Float32 `boil:"battery_pv_average_power_ac" json:"batteryPVAveragePowerAc,omitempty" toml:"batteryPVAveragePowerAc" yaml:"batteryPVAveragePowerAc,omitempty"`
	GridPvAveragePowerAC              null.Float32 `boil:"grid_pv_average_power_ac" json:"gridPVAveragePowerAc,omitempty" toml:"gridPVAveragePowerAc" yaml:"gridPVAveragePowerAc,omitempty"`
	GridProducedAveragePowerAC        null.Float32 `boil:"grid_produced_average_power_ac" json:"gridProducedAveragePowerAc,omitempty" toml:"gridProducedAveragePowerAc" yaml:"gridProducedAveragePowerAc,omitempty"`
	GridConsumedAveragePowerAC        null.Float32 `boil:"grid_consumed_average_power_ac" json:"gridConsumedAveragePowerAc,omitempty" toml:"gridConsumedAveragePowerAc" yaml:"gridConsumedAveragePowerAc,omitempty"`
	BatteryLifetimeOperationCycles    null.Float32 `boil:"battery_lifetime_operation_cycles" json:"batteryLifetimeOperationCycles,omitempty" toml:"batteryLifetimeOperationCycles" yaml:"batteryLifetimeOperationCycles,omitempty"`
	BatteryProducedLifetimeEnergyAC   null.Float32 `boil:"battery_produced_lifetime_energy_ac" json:"batteryProducedLifetimeEnergyAc,omitempty" toml:"batteryProducedLifetimeEnergyAc" yaml:"batteryProducedLifetimeEnergyAc,omitempty"`
	BatteryConsumedLifetimeEnergyAC   null.Float32 `boil:"battery_consumed_lifetime_energy_ac" json:"batteryConsumedLifetimeEnergyAc,omitempty" toml:"batteryConsumedLifetimeEnergyAc" yaml:"batteryConsumedLifetimeEnergyAc,omitempty"`
	BatteryAveragePowerAC             null.Float32 `boil:"battery_average_power_ac" json:"batteryAveragePowerAc,omitempty" toml:"batteryAveragePowerAc" yaml:"batteryAveragePowerAc,omitempty"`
	BatteryVoltage                    null.Float32 `boil:"battery_voltage" json:"batteryVoltage,omitempty" toml:"batteryVoltage" yaml:"batteryVoltage,omitempty"`
	AllProducedLifetimeEnergyAC       null.Float32 `boil:"all_produced_lifetime_energy_ac" json:"allProducedLifetimeEnergyAc,omitempty" toml:"allProducedLifetimeEnergyAc" yaml:"allProducedLifetimeEnergyAc,omitempty"`
	PvProducedLifetimeEnergyAC        null.Float32 `boil:"pv_produced_lifetime_energy_ac" json:"pvProducedLifetimeEnergyAc,omitempty" toml:"pvProducedLifetimeEnergyAc" yaml:"pvProducedLifetimeEnergyAc,omitempty"`
	GridProducedLifetimeEnergyAC      null.Float32 `boil:"grid_produced_lifetime_energy_ac" json:"gridProducedLifetimeEnergyAc,omitempty" toml:"gridProducedLifetimeEnergyAc" yaml:"gridProducedLifetimeEnergyAc,omitempty"`
	AllConsumedLifetimeEnergyAC       null.Float32 `boil:"all_consumed_lifetime_energy_ac" json:"allConsumedLifetimeEnergyAc,omitempty" toml:"allConsumedLifetimeEnergyAc" yaml:"allConsumedLifetimeEnergyAc,omitempty"`
	LoadConsumedLifetimeEnergyAC      null.Float32 `boil:"load_consumed_lifetime_energy_ac" json:"loadConsumedLifetimeEnergyAc,omitempty" toml:"loadConsumedLifetimeEnergyAc" yaml:"loadConsumedLifetimeEnergyAc,omitempty"`
	GridConsumedLifetimeEnergyAC      null.Float32 `boil:"grid_consumed_lifetime_energy_ac" json:"gridConsumedLifetimeEnergyAc,omitempty" toml:"gridConsumedLifetimeEnergyAc" yaml:"gridConsumedLifetimeEnergyAc,omitempty"`
	GridAveragePowerAC                null.Float32 `boil:"grid_average_power_ac" json:"gridAveragePowerAc,omitempty" toml:"gridAveragePowerAc" yaml:"gridAveragePowerAc,omitempty"`
	BatteryLifetimeEnergyAC           null.Float32 `boil:"battery_lifetime_energy_ac" json:"batteryLifetimeEnergyAc,omitempty" toml:"batteryLifetimeEnergyAc" yaml:"batteryLifetimeEnergyAc,omitempty"`
	GridLifetimeEnergyAC              null.Float32 `boil:"grid_lifetime_energy_ac" json:"gridLifetimeEnergyAc,omitempty" toml:"gridLifetimeEnergyAc" yaml:"gridLifetimeEnergyAc,omitempty"`
	LoadSelfConsumedLifetimeEnergyAC  null.Float32 `boil:"load_self_consumed_lifetime_energy_ac" json:"loadSelfConsumedLifetimeEnergyAc,omitempty" toml:"loadSelfConsumedLifetimeEnergyAc" yaml:"loadSelfConsumedLifetimeEnergyAc,omitempty"`
	GridPowerCost                     null.Float32 `boil:"grid_power_cost" json:"gridPowerCost,omitempty" toml:"gridPowerCost" yaml:"gridPowerCost,omitempty"`
	GridPowerCostSavings              null.Float32 `boil:"grid_power_cost_savings" json:"gridPowerCostSavings,omitempty" toml:"gridPowerCostSavings" yaml:"gridPowerCostSavings,omitempty"`
	LoadPvConsumedLifetimeEnergyAC    null.Float32 `boil:"load_pv_consumed_lifetime_energy_ac" json:"loadPVConsumedLifetimeEnergyAc,omitempty" toml:"loadPVConsumedLifetimeEnergyAc" yaml:"loadPVConsumedLifetimeEnergyAc,omitempty"`
	BatteryPvConsumedLifetimeEnergyAC null.Float32 `boil:"battery_pv_consumed_lifetime_energy_ac" json:"batteryPVConsumedLifetimeEnergyAc,omitempty" toml:"batteryPVConsumedLifetimeEnergyAc" yaml:"batteryPVConsumedLifetimeEnergyAc,omitempty"`
	GridPvConsumedLifetimeEnergyAC    null.Float32 `boil:"grid_pv_consumed_lifetime_energy_ac" json:"gridPVConsumedLifetimeEnergyAc,omitempty" toml:"gridPVConsumedLifetimeEnergyAc" yaml:"gridPVConsumedLifetimeEnergyAc,omitempty"`
	PvEnergyCostSavings               null.Float32 `boil:"pv_energy_cost_savings" json:"pvEnergyCostSavings,omitempty" toml:"pvEnergyCostSavings" yaml:"pvEnergyCostSavings,omitempty"`
	PvCo2Savings                      null.Float32 `boil:"pv_co2_savings" json:"pvCo2Savings,omitempty" toml:"pvCo2Savings" yaml:"pvCo2Savings,omitempty"`
	CreatedAt                         time.Time    `boil:"created_at" json:"createdAt" toml:"createdAt" yaml:"createdAt"`
	UpdatedAt                         null.Time    `boil:"updated_at" json:"updatedAt,omitempty" toml:"updatedAt" yaml:"updatedAt,omitempty"`

	R *ccDataLogR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L ccDataLogL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var CCDataLogColumns = struct {
	ID                                string
	GWUUID                            string
	LogDate                           string
	GWID                              string
	CustomerID                        string
	GridIsPeakShaving                 string
	LoadGridAveragePowerAC            string
	BatteryGridAveragePowerAC         string
	GridContractPowerAC               string
	LoadPvAveragePowerAC              string
	LoadBatteryAveragePowerAC         string
	BatterySoC                        string
	BatteryProducedAveragePowerAC     string
	BatteryConsumedAveragePowerAC     string
	BatteryChargingFrom               string
	BatteryDischargingTo              string
	PvAveragePowerAC                  string
	LoadAveragePowerAC                string
	LoadLinks                         string
	GridLinks                         string
	PvLinks                           string
	BatteryLinks                      string
	BatteryPvAveragePowerAC           string
	GridPvAveragePowerAC              string
	GridProducedAveragePowerAC        string
	GridConsumedAveragePowerAC        string
	BatteryLifetimeOperationCycles    string
	BatteryProducedLifetimeEnergyAC   string
	BatteryConsumedLifetimeEnergyAC   string
	BatteryAveragePowerAC             string
	BatteryVoltage                    string
	AllProducedLifetimeEnergyAC       string
	PvProducedLifetimeEnergyAC        string
	GridProducedLifetimeEnergyAC      string
	AllConsumedLifetimeEnergyAC       string
	LoadConsumedLifetimeEnergyAC      string
	GridConsumedLifetimeEnergyAC      string
	GridAveragePowerAC                string
	BatteryLifetimeEnergyAC           string
	GridLifetimeEnergyAC              string
	LoadSelfConsumedLifetimeEnergyAC  string
	GridPowerCost                     string
	GridPowerCostSavings              string
	LoadPvConsumedLifetimeEnergyAC    string
	BatteryPvConsumedLifetimeEnergyAC string
	GridPvConsumedLifetimeEnergyAC    string
	PvEnergyCostSavings               string
	PvCo2Savings                      string
	CreatedAt                         string
	UpdatedAt                         string
}{
	ID:                                "id",
	GWUUID:                            "gw_uuid",
	LogDate:                           "log_date",
	GWID:                              "gw_id",
	CustomerID:                        "customer_id",
	GridIsPeakShaving:                 "grid_is_peak_shaving",
	LoadGridAveragePowerAC:            "load_grid_average_power_ac",
	BatteryGridAveragePowerAC:         "battery_grid_average_power_ac",
	GridContractPowerAC:               "grid_contract_power_ac",
	LoadPvAveragePowerAC:              "load_pv_average_power_ac",
	LoadBatteryAveragePowerAC:         "load_battery_average_power_ac",
	BatterySoC:                        "battery_soc",
	BatteryProducedAveragePowerAC:     "battery_produced_average_power_ac",
	BatteryConsumedAveragePowerAC:     "battery_consumed_average_power_ac",
	BatteryChargingFrom:               "battery_charging_from",
	BatteryDischargingTo:              "battery_discharging_to",
	PvAveragePowerAC:                  "pv_average_power_ac",
	LoadAveragePowerAC:                "load_average_power_ac",
	LoadLinks:                         "load_links",
	GridLinks:                         "grid_links",
	PvLinks:                           "pv_links",
	BatteryLinks:                      "battery_links",
	BatteryPvAveragePowerAC:           "battery_pv_average_power_ac",
	GridPvAveragePowerAC:              "grid_pv_average_power_ac",
	GridProducedAveragePowerAC:        "grid_produced_average_power_ac",
	GridConsumedAveragePowerAC:        "grid_consumed_average_power_ac",
	BatteryLifetimeOperationCycles:    "battery_lifetime_operation_cycles",
	BatteryProducedLifetimeEnergyAC:   "battery_produced_lifetime_energy_ac",
	BatteryConsumedLifetimeEnergyAC:   "battery_consumed_lifetime_energy_ac",
	BatteryAveragePowerAC:             "battery_average_power_ac",
	BatteryVoltage:                    "battery_voltage",
	AllProducedLifetimeEnergyAC:       "all_produced_lifetime_energy_ac",
	PvProducedLifetimeEnergyAC:        "pv_produced_lifetime_energy_ac",
	GridProducedLifetimeEnergyAC:      "grid_produced_lifetime_energy_ac",
	AllConsumedLifetimeEnergyAC:       "all_consumed_lifetime_energy_ac",
	LoadConsumedLifetimeEnergyAC:      "load_consumed_lifetime_energy_ac",
	GridConsumedLifetimeEnergyAC:      "grid_consumed_lifetime_energy_ac",
	GridAveragePowerAC:                "grid_average_power_ac",
	BatteryLifetimeEnergyAC:           "battery_lifetime_energy_ac",
	GridLifetimeEnergyAC:              "grid_lifetime_energy_ac",
	LoadSelfConsumedLifetimeEnergyAC:  "load_self_consumed_lifetime_energy_ac",
	GridPowerCost:                     "grid_power_cost",
	GridPowerCostSavings:              "grid_power_cost_savings",
	LoadPvConsumedLifetimeEnergyAC:    "load_pv_consumed_lifetime_energy_ac",
	BatteryPvConsumedLifetimeEnergyAC: "battery_pv_consumed_lifetime_energy_ac",
	GridPvConsumedLifetimeEnergyAC:    "grid_pv_consumed_lifetime_energy_ac",
	PvEnergyCostSavings:               "pv_energy_cost_savings",
	PvCo2Savings:                      "pv_co2_savings",
	CreatedAt:                         "created_at",
	UpdatedAt:                         "updated_at",
}

var CCDataLogTableColumns = struct {
	ID                                string
	GWUUID                            string
	LogDate                           string
	GWID                              string
	CustomerID                        string
	GridIsPeakShaving                 string
	LoadGridAveragePowerAC            string
	BatteryGridAveragePowerAC         string
	GridContractPowerAC               string
	LoadPvAveragePowerAC              string
	LoadBatteryAveragePowerAC         string
	BatterySoC                        string
	BatteryProducedAveragePowerAC     string
	BatteryConsumedAveragePowerAC     string
	BatteryChargingFrom               string
	BatteryDischargingTo              string
	PvAveragePowerAC                  string
	LoadAveragePowerAC                string
	LoadLinks                         string
	GridLinks                         string
	PvLinks                           string
	BatteryLinks                      string
	BatteryPvAveragePowerAC           string
	GridPvAveragePowerAC              string
	GridProducedAveragePowerAC        string
	GridConsumedAveragePowerAC        string
	BatteryLifetimeOperationCycles    string
	BatteryProducedLifetimeEnergyAC   string
	BatteryConsumedLifetimeEnergyAC   string
	BatteryAveragePowerAC             string
	BatteryVoltage                    string
	AllProducedLifetimeEnergyAC       string
	PvProducedLifetimeEnergyAC        string
	GridProducedLifetimeEnergyAC      string
	AllConsumedLifetimeEnergyAC       string
	LoadConsumedLifetimeEnergyAC      string
	GridConsumedLifetimeEnergyAC      string
	GridAveragePowerAC                string
	BatteryLifetimeEnergyAC           string
	GridLifetimeEnergyAC              string
	LoadSelfConsumedLifetimeEnergyAC  string
	GridPowerCost                     string
	GridPowerCostSavings              string
	LoadPvConsumedLifetimeEnergyAC    string
	BatteryPvConsumedLifetimeEnergyAC string
	GridPvConsumedLifetimeEnergyAC    string
	PvEnergyCostSavings               string
	PvCo2Savings                      string
	CreatedAt                         string
	UpdatedAt                         string
}{
	ID:                                "cc_data_log.id",
	GWUUID:                            "cc_data_log.gw_uuid",
	LogDate:                           "cc_data_log.log_date",
	GWID:                              "cc_data_log.gw_id",
	CustomerID:                        "cc_data_log.customer_id",
	GridIsPeakShaving:                 "cc_data_log.grid_is_peak_shaving",
	LoadGridAveragePowerAC:            "cc_data_log.load_grid_average_power_ac",
	BatteryGridAveragePowerAC:         "cc_data_log.battery_grid_average_power_ac",
	GridContractPowerAC:               "cc_data_log.grid_contract_power_ac",
	LoadPvAveragePowerAC:              "cc_data_log.load_pv_average_power_ac",
	LoadBatteryAveragePowerAC:         "cc_data_log.load_battery_average_power_ac",
	BatterySoC:                        "cc_data_log.battery_soc",
	BatteryProducedAveragePowerAC:     "cc_data_log.battery_produced_average_power_ac",
	BatteryConsumedAveragePowerAC:     "cc_data_log.battery_consumed_average_power_ac",
	BatteryChargingFrom:               "cc_data_log.battery_charging_from",
	BatteryDischargingTo:              "cc_data_log.battery_discharging_to",
	PvAveragePowerAC:                  "cc_data_log.pv_average_power_ac",
	LoadAveragePowerAC:                "cc_data_log.load_average_power_ac",
	LoadLinks:                         "cc_data_log.load_links",
	GridLinks:                         "cc_data_log.grid_links",
	PvLinks:                           "cc_data_log.pv_links",
	BatteryLinks:                      "cc_data_log.battery_links",
	BatteryPvAveragePowerAC:           "cc_data_log.battery_pv_average_power_ac",
	GridPvAveragePowerAC:              "cc_data_log.grid_pv_average_power_ac",
	GridProducedAveragePowerAC:        "cc_data_log.grid_produced_average_power_ac",
	GridConsumedAveragePowerAC:        "cc_data_log.grid_consumed_average_power_ac",
	BatteryLifetimeOperationCycles:    "cc_data_log.battery_lifetime_operation_cycles",
	BatteryProducedLifetimeEnergyAC:   "cc_data_log.battery_produced_lifetime_energy_ac",
	BatteryConsumedLifetimeEnergyAC:   "cc_data_log.battery_consumed_lifetime_energy_ac",
	BatteryAveragePowerAC:             "cc_data_log.battery_average_power_ac",
	BatteryVoltage:                    "cc_data_log.battery_voltage",
	AllProducedLifetimeEnergyAC:       "cc_data_log.all_produced_lifetime_energy_ac",
	PvProducedLifetimeEnergyAC:        "cc_data_log.pv_produced_lifetime_energy_ac",
	GridProducedLifetimeEnergyAC:      "cc_data_log.grid_produced_lifetime_energy_ac",
	AllConsumedLifetimeEnergyAC:       "cc_data_log.all_consumed_lifetime_energy_ac",
	LoadConsumedLifetimeEnergyAC:      "cc_data_log.load_consumed_lifetime_energy_ac",
	GridConsumedLifetimeEnergyAC:      "cc_data_log.grid_consumed_lifetime_energy_ac",
	GridAveragePowerAC:                "cc_data_log.grid_average_power_ac",
	BatteryLifetimeEnergyAC:           "cc_data_log.battery_lifetime_energy_ac",
	GridLifetimeEnergyAC:              "cc_data_log.grid_lifetime_energy_ac",
	LoadSelfConsumedLifetimeEnergyAC:  "cc_data_log.load_self_consumed_lifetime_energy_ac",
	GridPowerCost:                     "cc_data_log.grid_power_cost",
	GridPowerCostSavings:              "cc_data_log.grid_power_cost_savings",
	LoadPvConsumedLifetimeEnergyAC:    "cc_data_log.load_pv_consumed_lifetime_energy_ac",
	BatteryPvConsumedLifetimeEnergyAC: "cc_data_log.battery_pv_consumed_lifetime_energy_ac",
	GridPvConsumedLifetimeEnergyAC:    "cc_data_log.grid_pv_consumed_lifetime_energy_ac",
	PvEnergyCostSavings:               "cc_data_log.pv_energy_cost_savings",
	PvCo2Savings:                      "cc_data_log.pv_co2_savings",
	CreatedAt:                         "cc_data_log.created_at",
	UpdatedAt:                         "cc_data_log.updated_at",
}

// Generated where

type whereHelpernull_Int struct{ field string }

func (w whereHelpernull_Int) EQ(x null.Int) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Int) NEQ(x null.Int) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Int) LT(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Int) LTE(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Int) GT(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Int) GTE(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

func (w whereHelpernull_Int) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Int) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

type whereHelpernull_Float32 struct{ field string }

func (w whereHelpernull_Float32) EQ(x null.Float32) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Float32) NEQ(x null.Float32) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Float32) LT(x null.Float32) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Float32) LTE(x null.Float32) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Float32) GT(x null.Float32) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Float32) GTE(x null.Float32) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

func (w whereHelpernull_Float32) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Float32) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

type whereHelpernull_String struct{ field string }

func (w whereHelpernull_String) EQ(x null.String) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_String) NEQ(x null.String) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_String) LT(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_String) LTE(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_String) GT(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_String) GTE(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

func (w whereHelpernull_String) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_String) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

var CCDataLogWhere = struct {
	ID                                whereHelperint64
	GWUUID                            whereHelperstring
	LogDate                           whereHelpertime_Time
	GWID                              whereHelpernull_Int64
	CustomerID                        whereHelpernull_Int64
	GridIsPeakShaving                 whereHelpernull_Int
	LoadGridAveragePowerAC            whereHelpernull_Float32
	BatteryGridAveragePowerAC         whereHelpernull_Float32
	GridContractPowerAC               whereHelpernull_Float32
	LoadPvAveragePowerAC              whereHelpernull_Float32
	LoadBatteryAveragePowerAC         whereHelpernull_Float32
	BatterySoC                        whereHelpernull_Float32
	BatteryProducedAveragePowerAC     whereHelpernull_Float32
	BatteryConsumedAveragePowerAC     whereHelpernull_Float32
	BatteryChargingFrom               whereHelpernull_String
	BatteryDischargingTo              whereHelpernull_String
	PvAveragePowerAC                  whereHelpernull_Float32
	LoadAveragePowerAC                whereHelpernull_Float32
	LoadLinks                         whereHelpernull_JSON
	GridLinks                         whereHelpernull_JSON
	PvLinks                           whereHelpernull_JSON
	BatteryLinks                      whereHelpernull_JSON
	BatteryPvAveragePowerAC           whereHelpernull_Float32
	GridPvAveragePowerAC              whereHelpernull_Float32
	GridProducedAveragePowerAC        whereHelpernull_Float32
	GridConsumedAveragePowerAC        whereHelpernull_Float32
	BatteryLifetimeOperationCycles    whereHelpernull_Float32
	BatteryProducedLifetimeEnergyAC   whereHelpernull_Float32
	BatteryConsumedLifetimeEnergyAC   whereHelpernull_Float32
	BatteryAveragePowerAC             whereHelpernull_Float32
	BatteryVoltage                    whereHelpernull_Float32
	AllProducedLifetimeEnergyAC       whereHelpernull_Float32
	PvProducedLifetimeEnergyAC        whereHelpernull_Float32
	GridProducedLifetimeEnergyAC      whereHelpernull_Float32
	AllConsumedLifetimeEnergyAC       whereHelpernull_Float32
	LoadConsumedLifetimeEnergyAC      whereHelpernull_Float32
	GridConsumedLifetimeEnergyAC      whereHelpernull_Float32
	GridAveragePowerAC                whereHelpernull_Float32
	BatteryLifetimeEnergyAC           whereHelpernull_Float32
	GridLifetimeEnergyAC              whereHelpernull_Float32
	LoadSelfConsumedLifetimeEnergyAC  whereHelpernull_Float32
	GridPowerCost                     whereHelpernull_Float32
	GridPowerCostSavings              whereHelpernull_Float32
	LoadPvConsumedLifetimeEnergyAC    whereHelpernull_Float32
	BatteryPvConsumedLifetimeEnergyAC whereHelpernull_Float32
	GridPvConsumedLifetimeEnergyAC    whereHelpernull_Float32
	PvEnergyCostSavings               whereHelpernull_Float32
	PvCo2Savings                      whereHelpernull_Float32
	CreatedAt                         whereHelpertime_Time
	UpdatedAt                         whereHelpernull_Time
}{
	ID:                                whereHelperint64{field: "`cc_data_log`.`id`"},
	GWUUID:                            whereHelperstring{field: "`cc_data_log`.`gw_uuid`"},
	LogDate:                           whereHelpertime_Time{field: "`cc_data_log`.`log_date`"},
	GWID:                              whereHelpernull_Int64{field: "`cc_data_log`.`gw_id`"},
	CustomerID:                        whereHelpernull_Int64{field: "`cc_data_log`.`customer_id`"},
	GridIsPeakShaving:                 whereHelpernull_Int{field: "`cc_data_log`.`grid_is_peak_shaving`"},
	LoadGridAveragePowerAC:            whereHelpernull_Float32{field: "`cc_data_log`.`load_grid_average_power_ac`"},
	BatteryGridAveragePowerAC:         whereHelpernull_Float32{field: "`cc_data_log`.`battery_grid_average_power_ac`"},
	GridContractPowerAC:               whereHelpernull_Float32{field: "`cc_data_log`.`grid_contract_power_ac`"},
	LoadPvAveragePowerAC:              whereHelpernull_Float32{field: "`cc_data_log`.`load_pv_average_power_ac`"},
	LoadBatteryAveragePowerAC:         whereHelpernull_Float32{field: "`cc_data_log`.`load_battery_average_power_ac`"},
	BatterySoC:                        whereHelpernull_Float32{field: "`cc_data_log`.`battery_soc`"},
	BatteryProducedAveragePowerAC:     whereHelpernull_Float32{field: "`cc_data_log`.`battery_produced_average_power_ac`"},
	BatteryConsumedAveragePowerAC:     whereHelpernull_Float32{field: "`cc_data_log`.`battery_consumed_average_power_ac`"},
	BatteryChargingFrom:               whereHelpernull_String{field: "`cc_data_log`.`battery_charging_from`"},
	BatteryDischargingTo:              whereHelpernull_String{field: "`cc_data_log`.`battery_discharging_to`"},
	PvAveragePowerAC:                  whereHelpernull_Float32{field: "`cc_data_log`.`pv_average_power_ac`"},
	LoadAveragePowerAC:                whereHelpernull_Float32{field: "`cc_data_log`.`load_average_power_ac`"},
	LoadLinks:                         whereHelpernull_JSON{field: "`cc_data_log`.`load_links`"},
	GridLinks:                         whereHelpernull_JSON{field: "`cc_data_log`.`grid_links`"},
	PvLinks:                           whereHelpernull_JSON{field: "`cc_data_log`.`pv_links`"},
	BatteryLinks:                      whereHelpernull_JSON{field: "`cc_data_log`.`battery_links`"},
	BatteryPvAveragePowerAC:           whereHelpernull_Float32{field: "`cc_data_log`.`battery_pv_average_power_ac`"},
	GridPvAveragePowerAC:              whereHelpernull_Float32{field: "`cc_data_log`.`grid_pv_average_power_ac`"},
	GridProducedAveragePowerAC:        whereHelpernull_Float32{field: "`cc_data_log`.`grid_produced_average_power_ac`"},
	GridConsumedAveragePowerAC:        whereHelpernull_Float32{field: "`cc_data_log`.`grid_consumed_average_power_ac`"},
	BatteryLifetimeOperationCycles:    whereHelpernull_Float32{field: "`cc_data_log`.`battery_lifetime_operation_cycles`"},
	BatteryProducedLifetimeEnergyAC:   whereHelpernull_Float32{field: "`cc_data_log`.`battery_produced_lifetime_energy_ac`"},
	BatteryConsumedLifetimeEnergyAC:   whereHelpernull_Float32{field: "`cc_data_log`.`battery_consumed_lifetime_energy_ac`"},
	BatteryAveragePowerAC:             whereHelpernull_Float32{field: "`cc_data_log`.`battery_average_power_ac`"},
	BatteryVoltage:                    whereHelpernull_Float32{field: "`cc_data_log`.`battery_voltage`"},
	AllProducedLifetimeEnergyAC:       whereHelpernull_Float32{field: "`cc_data_log`.`all_produced_lifetime_energy_ac`"},
	PvProducedLifetimeEnergyAC:        whereHelpernull_Float32{field: "`cc_data_log`.`pv_produced_lifetime_energy_ac`"},
	GridProducedLifetimeEnergyAC:      whereHelpernull_Float32{field: "`cc_data_log`.`grid_produced_lifetime_energy_ac`"},
	AllConsumedLifetimeEnergyAC:       whereHelpernull_Float32{field: "`cc_data_log`.`all_consumed_lifetime_energy_ac`"},
	LoadConsumedLifetimeEnergyAC:      whereHelpernull_Float32{field: "`cc_data_log`.`load_consumed_lifetime_energy_ac`"},
	GridConsumedLifetimeEnergyAC:      whereHelpernull_Float32{field: "`cc_data_log`.`grid_consumed_lifetime_energy_ac`"},
	GridAveragePowerAC:                whereHelpernull_Float32{field: "`cc_data_log`.`grid_average_power_ac`"},
	BatteryLifetimeEnergyAC:           whereHelpernull_Float32{field: "`cc_data_log`.`battery_lifetime_energy_ac`"},
	GridLifetimeEnergyAC:              whereHelpernull_Float32{field: "`cc_data_log`.`grid_lifetime_energy_ac`"},
	LoadSelfConsumedLifetimeEnergyAC:  whereHelpernull_Float32{field: "`cc_data_log`.`load_self_consumed_lifetime_energy_ac`"},
	GridPowerCost:                     whereHelpernull_Float32{field: "`cc_data_log`.`grid_power_cost`"},
	GridPowerCostSavings:              whereHelpernull_Float32{field: "`cc_data_log`.`grid_power_cost_savings`"},
	LoadPvConsumedLifetimeEnergyAC:    whereHelpernull_Float32{field: "`cc_data_log`.`load_pv_consumed_lifetime_energy_ac`"},
	BatteryPvConsumedLifetimeEnergyAC: whereHelpernull_Float32{field: "`cc_data_log`.`battery_pv_consumed_lifetime_energy_ac`"},
	GridPvConsumedLifetimeEnergyAC:    whereHelpernull_Float32{field: "`cc_data_log`.`grid_pv_consumed_lifetime_energy_ac`"},
	PvEnergyCostSavings:               whereHelpernull_Float32{field: "`cc_data_log`.`pv_energy_cost_savings`"},
	PvCo2Savings:                      whereHelpernull_Float32{field: "`cc_data_log`.`pv_co2_savings`"},
	CreatedAt:                         whereHelpertime_Time{field: "`cc_data_log`.`created_at`"},
	UpdatedAt:                         whereHelpernull_Time{field: "`cc_data_log`.`updated_at`"},
}

// CCDataLogRels is where relationship names are stored.
var CCDataLogRels = struct {
}{}

// ccDataLogR is where relationships are stored.
type ccDataLogR struct {
}

// NewStruct creates a new relationship struct
func (*ccDataLogR) NewStruct() *ccDataLogR {
	return &ccDataLogR{}
}

// ccDataLogL is where Load methods for each relationship are stored.
type ccDataLogL struct{}

var (
	ccDataLogAllColumns            = []string{"id", "gw_uuid", "log_date", "gw_id", "customer_id", "grid_is_peak_shaving", "load_grid_average_power_ac", "battery_grid_average_power_ac", "grid_contract_power_ac", "load_pv_average_power_ac", "load_battery_average_power_ac", "battery_soc", "battery_produced_average_power_ac", "battery_consumed_average_power_ac", "battery_charging_from", "battery_discharging_to", "pv_average_power_ac", "load_average_power_ac", "load_links", "grid_links", "pv_links", "battery_links", "battery_pv_average_power_ac", "grid_pv_average_power_ac", "grid_produced_average_power_ac", "grid_consumed_average_power_ac", "battery_lifetime_operation_cycles", "battery_produced_lifetime_energy_ac", "battery_consumed_lifetime_energy_ac", "battery_average_power_ac", "battery_voltage", "all_produced_lifetime_energy_ac", "pv_produced_lifetime_energy_ac", "grid_produced_lifetime_energy_ac", "all_consumed_lifetime_energy_ac", "load_consumed_lifetime_energy_ac", "grid_consumed_lifetime_energy_ac", "grid_average_power_ac", "battery_lifetime_energy_ac", "grid_lifetime_energy_ac", "load_self_consumed_lifetime_energy_ac", "grid_power_cost", "grid_power_cost_savings", "load_pv_consumed_lifetime_energy_ac", "battery_pv_consumed_lifetime_energy_ac", "grid_pv_consumed_lifetime_energy_ac", "pv_energy_cost_savings", "pv_co2_savings", "created_at", "updated_at"}
	ccDataLogColumnsWithoutDefault = []string{"gw_uuid", "log_date", "gw_id", "customer_id", "grid_is_peak_shaving", "load_grid_average_power_ac", "battery_grid_average_power_ac", "grid_contract_power_ac", "load_pv_average_power_ac", "load_battery_average_power_ac", "battery_soc", "battery_produced_average_power_ac", "battery_consumed_average_power_ac", "battery_charging_from", "battery_discharging_to", "pv_average_power_ac", "load_average_power_ac", "load_links", "grid_links", "pv_links", "battery_links", "battery_pv_average_power_ac", "grid_pv_average_power_ac", "grid_produced_average_power_ac", "grid_consumed_average_power_ac", "battery_lifetime_operation_cycles", "battery_produced_lifetime_energy_ac", "battery_consumed_lifetime_energy_ac", "battery_average_power_ac", "battery_voltage", "all_produced_lifetime_energy_ac", "pv_produced_lifetime_energy_ac", "grid_produced_lifetime_energy_ac", "all_consumed_lifetime_energy_ac", "load_consumed_lifetime_energy_ac", "grid_consumed_lifetime_energy_ac", "grid_average_power_ac", "battery_lifetime_energy_ac", "grid_lifetime_energy_ac", "load_self_consumed_lifetime_energy_ac", "grid_power_cost", "grid_power_cost_savings", "load_pv_consumed_lifetime_energy_ac", "battery_pv_consumed_lifetime_energy_ac", "grid_pv_consumed_lifetime_energy_ac", "pv_energy_cost_savings", "pv_co2_savings", "updated_at"}
	ccDataLogColumnsWithDefault    = []string{"id", "created_at"}
	ccDataLogPrimaryKeyColumns     = []string{"id"}
	ccDataLogGeneratedColumns      = []string{}
)

type (
	// CCDataLogSlice is an alias for a slice of pointers to CCDataLog.
	// This should almost always be used instead of []CCDataLog.
	CCDataLogSlice []*CCDataLog

	ccDataLogQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	ccDataLogType                 = reflect.TypeOf(&CCDataLog{})
	ccDataLogMapping              = queries.MakeStructMapping(ccDataLogType)
	ccDataLogPrimaryKeyMapping, _ = queries.BindMapping(ccDataLogType, ccDataLogMapping, ccDataLogPrimaryKeyColumns)
	ccDataLogInsertCacheMut       sync.RWMutex
	ccDataLogInsertCache          = make(map[string]insertCache)
	ccDataLogUpdateCacheMut       sync.RWMutex
	ccDataLogUpdateCache          = make(map[string]updateCache)
	ccDataLogUpsertCacheMut       sync.RWMutex
	ccDataLogUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

// One returns a single ccDataLog record from the query.
func (q ccDataLogQuery) One(exec boil.Executor) (*CCDataLog, error) {
	o := &CCDataLog{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(nil, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "deremsmodels: failed to execute a one query for cc_data_log")
	}

	return o, nil
}

// All returns all CCDataLog records from the query.
func (q ccDataLogQuery) All(exec boil.Executor) (CCDataLogSlice, error) {
	var o []*CCDataLog

	err := q.Bind(nil, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "deremsmodels: failed to assign all query results to CCDataLog slice")
	}

	return o, nil
}

// Count returns the count of all CCDataLog records in the query.
func (q ccDataLogQuery) Count(exec boil.Executor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "deremsmodels: failed to count cc_data_log rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q ccDataLogQuery) Exists(exec boil.Executor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "deremsmodels: failed to check if cc_data_log exists")
	}

	return count > 0, nil
}

// CCDataLogs retrieves all the records using an executor.
func CCDataLogs(mods ...qm.QueryMod) ccDataLogQuery {
	mods = append(mods, qm.From("`cc_data_log`"))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"`cc_data_log`.*"})
	}

	return ccDataLogQuery{q}
}

// FindCCDataLog retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindCCDataLog(exec boil.Executor, iD int64, selectCols ...string) (*CCDataLog, error) {
	ccDataLogObj := &CCDataLog{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `cc_data_log` where `id`=?", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(nil, exec, ccDataLogObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "deremsmodels: unable to select from cc_data_log")
	}

	return ccDataLogObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *CCDataLog) Insert(exec boil.Executor, columns boil.Columns) error {
	if o == nil {
		return errors.New("deremsmodels: no cc_data_log provided for insertion")
	}

	var err error
	currTime := time.Now().In(boil.GetLocation())

	if o.CreatedAt.IsZero() {
		o.CreatedAt = currTime
	}
	if queries.MustTime(o.UpdatedAt).IsZero() {
		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	nzDefaults := queries.NonZeroDefaultSet(ccDataLogColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	ccDataLogInsertCacheMut.RLock()
	cache, cached := ccDataLogInsertCache[key]
	ccDataLogInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			ccDataLogAllColumns,
			ccDataLogColumnsWithDefault,
			ccDataLogColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(ccDataLogType, ccDataLogMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(ccDataLogType, ccDataLogMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `cc_data_log` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `cc_data_log` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `cc_data_log` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, ccDataLogPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}
	result, err := exec.Exec(cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "deremsmodels: unable to insert into cc_data_log")
	}

	var lastID int64
	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = int64(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == ccDataLogMapping["id"] {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.ID,
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, identifierCols...)
	}
	err = exec.QueryRow(cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "deremsmodels: unable to populate default values for cc_data_log")
	}

CacheNoHooks:
	if !cached {
		ccDataLogInsertCacheMut.Lock()
		ccDataLogInsertCache[key] = cache
		ccDataLogInsertCacheMut.Unlock()
	}

	return nil
}

// Update uses an executor to update the CCDataLog.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *CCDataLog) Update(exec boil.Executor, columns boil.Columns) (int64, error) {
	currTime := time.Now().In(boil.GetLocation())

	queries.SetScanner(&o.UpdatedAt, currTime)

	var err error
	key := makeCacheKey(columns, nil)
	ccDataLogUpdateCacheMut.RLock()
	cache, cached := ccDataLogUpdateCache[key]
	ccDataLogUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			ccDataLogAllColumns,
			ccDataLogPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("deremsmodels: unable to update cc_data_log, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `cc_data_log` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, ccDataLogPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(ccDataLogType, ccDataLogMapping, append(wl, ccDataLogPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	var result sql.Result
	result, err = exec.Exec(cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "deremsmodels: unable to update cc_data_log row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "deremsmodels: failed to get rows affected by update for cc_data_log")
	}

	if !cached {
		ccDataLogUpdateCacheMut.Lock()
		ccDataLogUpdateCache[key] = cache
		ccDataLogUpdateCacheMut.Unlock()
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values.
func (q ccDataLogQuery) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "deremsmodels: unable to update all for cc_data_log")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "deremsmodels: unable to retrieve rows affected for cc_data_log")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o CCDataLogSlice) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("deremsmodels: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), ccDataLogPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `cc_data_log` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, ccDataLogPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "deremsmodels: unable to update all in ccDataLog slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "deremsmodels: unable to retrieve rows affected all in update all ccDataLog")
	}
	return rowsAff, nil
}

var mySQLCCDataLogUniqueColumns = []string{
	"id",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *CCDataLog) Upsert(exec boil.Executor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("deremsmodels: no cc_data_log provided for upsert")
	}
	currTime := time.Now().In(boil.GetLocation())

	if o.CreatedAt.IsZero() {
		o.CreatedAt = currTime
	}
	queries.SetScanner(&o.UpdatedAt, currTime)

	nzDefaults := queries.NonZeroDefaultSet(ccDataLogColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLCCDataLogUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	ccDataLogUpsertCacheMut.RLock()
	cache, cached := ccDataLogUpsertCache[key]
	ccDataLogUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			ccDataLogAllColumns,
			ccDataLogColumnsWithDefault,
			ccDataLogColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			ccDataLogAllColumns,
			ccDataLogPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("deremsmodels: unable to upsert cc_data_log, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "`cc_data_log`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `cc_data_log` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(ccDataLogType, ccDataLogMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(ccDataLogType, ccDataLogMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}
	result, err := exec.Exec(cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "deremsmodels: unable to upsert for cc_data_log")
	}

	var lastID int64
	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = int64(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == ccDataLogMapping["id"] {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(ccDataLogType, ccDataLogMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "deremsmodels: unable to retrieve unique values for cc_data_log")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.retQuery)
		fmt.Fprintln(boil.DebugWriter, nzUniqueCols...)
	}
	err = exec.QueryRow(cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "deremsmodels: unable to populate default values for cc_data_log")
	}

CacheNoHooks:
	if !cached {
		ccDataLogUpsertCacheMut.Lock()
		ccDataLogUpsertCache[key] = cache
		ccDataLogUpsertCacheMut.Unlock()
	}

	return nil
}

// Delete deletes a single CCDataLog record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *CCDataLog) Delete(exec boil.Executor) (int64, error) {
	if o == nil {
		return 0, errors.New("deremsmodels: no CCDataLog provided for delete")
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), ccDataLogPrimaryKeyMapping)
	sql := "DELETE FROM `cc_data_log` WHERE `id`=?"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "deremsmodels: unable to delete from cc_data_log")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "deremsmodels: failed to get rows affected by delete for cc_data_log")
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q ccDataLogQuery) DeleteAll(exec boil.Executor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("deremsmodels: no ccDataLogQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "deremsmodels: unable to delete all from cc_data_log")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "deremsmodels: failed to get rows affected by deleteall for cc_data_log")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o CCDataLogSlice) DeleteAll(exec boil.Executor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), ccDataLogPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `cc_data_log` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, ccDataLogPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "deremsmodels: unable to delete all from ccDataLog slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "deremsmodels: failed to get rows affected by deleteall for cc_data_log")
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *CCDataLog) Reload(exec boil.Executor) error {
	ret, err := FindCCDataLog(exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *CCDataLogSlice) ReloadAll(exec boil.Executor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := CCDataLogSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), ccDataLogPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `cc_data_log`.* FROM `cc_data_log` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, ccDataLogPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(nil, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "deremsmodels: unable to reload all in CCDataLogSlice")
	}

	*o = slice

	return nil
}

// CCDataLogExists checks if the CCDataLog row exists.
func CCDataLogExists(exec boil.Executor, iD int64) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `cc_data_log` where `id`=? limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, iD)
	}
	row := exec.QueryRow(sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "deremsmodels: unable to check if cc_data_log exists")
	}

	return exists, nil
}
